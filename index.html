<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .neighborhood {
        fill: none;
        stroke: #000;
        stroke-linejoin: round;
    }
    </style>
</head>
<body>
    <svg id="boston" height="600" width="600" style="margin: 20px"></svg>
    <svg id="nyc" height="600" width="600" style="margin: 20px"></svg>
    <script>

        const createVisualiation= async function(){
            const bostonmap = await d3.json("boston.topojson")
            const bostonsvg = d3.select("#boston")
            let margin = bostonsvg.attr("margin")
            let mapWidth = bostonsvg.attr("width")
            let mapHeight = bostonsvg.attr("height")

            const bostonvisualization = bostonsvg.append("g");
            var bostonMesh = topojson.mesh(bostonmap,bostonmap.objects.boston)
            let bostonFeature = topojson.feature(bostonmap,bostonmap.objects.boston)
            let bostonproj = d3.geoMercator().fitSize([mapWidth, mapHeight], bostonMesh)
            let bostonpath = d3.geoPath().projection(bostonproj)

            let bostonSelection = bostonvisualization.selectAll("path")
                                                    .data(bostonFeature.features)
                                                    .join("path")
                                                    .attr("fill", "white")
                                                    .attr("stroke", "black")
                                                    .attr("d", bostonpath);

            let bostonMeshPath = bostonvisualization.append("path")
                                                    .datum(bostonMesh)
                                                    .attr("d", bostonpath)
                                                    .attr("stroke", "black")
                                                    .attr("stroke-width", 1)
                                                    .attr("fill", "none");


            const nycmap = await d3.json("NTA.topojson")
            const nycsvg = d3.select("#nyc")
            const nycvisualization = nycsvg.append("g");
            var nycMesh = topojson.mesh(nycmap,nycmap.objects.collection)
            let nycFeature = topojson.feature(nycmap,nycmap.objects.collection)
            let nycproj = d3.geoMercator().fitSize([mapWidth, mapHeight], nycMesh)
            let nycpath = d3.geoPath().projection(nycproj)

            let nycSelection = nycvisualization.selectAll("path")
                                                    .data(nycFeature.features)
                                                    .join("path")
                                                    .attr("fill", "white")
                                                    .attr("stroke", "black")
                                                    .attr("d", nycpath);

            let nycMeshPath = nycvisualization.append("path")
                                                    .datum(nycMesh)
                                                    .attr("d", nycpath)
                                                    .attr("stroke", "black")
                                                    .attr("stroke-width", 1)
                                                    .attr("fill", "none");

        }

        createVisualiation()

        // FUNCTION FOR CLEANING DATA. EDIT FOR OTHER CHANGES.
        async function trimNYC(path){

            let nyc= await d3.csv(path)
            let boroughs= {}

            // Shuffle array to get random data points 
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    // Swap array[i] and array[j]
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // Get all elements from dataset for each of the neighborhoods of nyc
            nyc.map((element)=>{
                let borough= element.neighbourhood
                if (borough in boroughs){
                    boroughs[borough].push(element)
                }
                else{
                    boroughs[borough]=[]
                    boroughs[borough].push(element)
                }
            })
            
            let final={}

            // Shuffle each of the datasets for each of the boroughs and get 20 percent of the elements.
            for(const key in boroughs){
                let item= boroughs[key]
                shuffleArray(item)
                let length= item.length
                let tenPercent= Math.ceil(.2*length)
                final[key]= item.slice(0,tenPercent)
            }

            

            return final
        }

        async function trimBoston(path){
            let boston= await d3.csv(path)
            let boroughs= {}

            // Shuffle array to get random data points 
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    // Swap array[i] and array[j]
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // Get all elements from dataset for each of the boroughs of nyc.
            boston.map((element)=>{
                let borough= element.neighbourhood
                if (borough in boroughs){
                    boroughs[borough].push(element)
                }
                else{
                    boroughs[borough]=[]
                    boroughs[borough].push(element)
                }
            })

            return boroughs
        }



        // UNCOMMENT IF EDITING DATA IS NEEDED AGAIN
        // let nycFinal=trimNYC("./listings.csv")
        // let bostonFinal=trimBoston("./listings-2.csv")

        // Promise.all([nycFinal,bostonFinal])
        //         .then(([data,data2])=>{
        //             let merge= {}

        //             for(let index in data){
        //                 merge[index]=data[index]
        //             }

        //             for (let index2 in data2){
        //                 merge[index2]=data2[index2]
        //             }

        //             let stringify= JSON.stringify(merge)
                    
        //         })
    </script>
</body>
</html>